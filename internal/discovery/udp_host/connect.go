package udp_host

import (
	"fmt"
	"net"
	"time"

	"github.com/yty0v0/ReconQuiver/internal/scanner"
)

// UDP扫描结果结构
type UDPResultSurvival struct {
	IP    string
	State string
}

// UDP端口扫描操作
func Udp_connect(ipaddres []string) {
	var results []UDPResultSurvival
	sem := make(chan struct{}, 500) // 并发控制

	fmt.Println("开始UDP扫描...")
	start := time.Now()

	for _, ipaddr := range ipaddres {
		//扫描端口不要设置太多，可能会触发目标的防护机制
		keyPorts := []int{53, 67, 68, 69, 111, 123, 137, 138, 161, 500, 514, 520, 1434, 1900, 3306, 4500, 5353, 5432, 19132, 27015}
		for _, port := range keyPorts {
			scanner.Wg.Add(1)
			go func(p int, ipaddr string) {
				sem <- struct{}{}        // 获取信号量
				defer func() { <-sem }() // 释放信号量
				defer scanner.Wg.Done()

				check := scanUDPPort(ipaddr, p, 3*time.Second)

				if check {
					scanner.Mu.Lock()
					result := UDPResultSurvival{
						IP:    ipaddr,
						State: "up",
					}
					results = append(results, result)
					scanner.Mu.Unlock()
				}

			}(port, ipaddr)
		}
	}
	scanner.Wg.Wait()

	// 输出扫描结果
	fmt.Println("\n扫描结果:")
	fmt.Println("IP地址\t\t状态")
	//fmt.Println("----\t----\t\t----")
	had := make(map[string]int) //去重用
	for _, result := range results {
		//过滤重复记录的ip地址
		if had[result.IP] == 0 {
			fmt.Printf("%s\t%s\n", result.IP, result.State)
		}
		had[result.IP]++
	}

	usetime := time.Since(start)
	fmt.Println()
	fmt.Printf("扫描完成，耗时: %v\n", usetime)
}

// UDP端口扫描函数
func scanUDPPort(ip string, port int, timeout time.Duration) bool {

	// 构造目标地址
	target := fmt.Sprintf("%s:%d", ip, port)

	// 创建UDP连接
	conn, err := net.DialTimeout("udp", target, timeout)
	if err != nil {
		return false
	}
	defer conn.Close()

	// 发送探测数据
	probeData := getProbeData(port)
	_, err = conn.Write(probeData)
	if err != nil {
		return false
	}

	buffer := make([]byte, 1024)

	//设置总超时
	deadline := time.Now().Add(timeout)

	for {
		// 设置读写超时
		conn.SetDeadline(time.Now().Add(200 * time.Millisecond))

		//总读取超时直接返回
		if time.Now().After(deadline) {
			// 超时，可能是开放或被过滤
			return false
		}

		// 尝试接收UDP响应
		n, err := conn.Read(buffer)

		if err != nil {
			// 检查是否是超时错误
			if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
				//短超时直接下一轮循环
				continue
			} else {
				return false
			}
		} else {
			// 收到响应，端口开放
			if n > 0 {
				//fmt.Printf("端口 %d 收到响应，长度: %d 字节\n", port, n)
				return true
			}
		}
	}
}

// 探测数据
func getProbeData(port int) []byte {
	switch port {
	case 53: // DNS
		return []byte{
			0x12, 0x34, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x07, 'e', 'x', 'a',
			'm', 'p', 'l', 'e', 0x03, 'c', 'o', 'm', 0x00,
			0x00, 0x01, 0x00, 0x01,
		}
	case 111: // RPC portmap - 使用NULL调用
		return []byte{
			0x00, 0x00, 0x00, 0x00, // XID
			0x00, 0x00, 0x00, 0x00, // Message Type: Call (0)
			0x00, 0x00, 0x00, 0x02, // RPC Version: 2
			0x00, 0x00, 0x00, 0x00, // Program: 0 (NULL测试)
			0x00, 0x00, 0x00, 0x00, // Program Version: 0
			0x00, 0x00, 0x00, 0x00, // Procedure: NULL (0)
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		}
	case 123: // NTP
		return []byte{0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	case 161: // SNMP
		return []byte{0x30, 0x29, 0x02, 0x01, 0x00, 0x04, 0x06, 0x70, 0x75, 0x62, 0x6C, 0x69, 0x63, 0xA0, 0x1C, 0x02, 0x04, 0x71, 0x97, 0x81, 0x75, 0x02, 0x01, 0x00, 0x02, 0x01, 0x00, 0x30, 0x0E, 0x30, 0x0C, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00, 0x05, 0x00}
	case 137: // NetBIOS Name Service
		return []byte{
			0x12, 0x34, // Transaction ID
			0x00, 0x00, // Flags: Query
			0x00, 0x01, // Questions: 1
			0x00, 0x00, // Answer RRs: 0
			0x00, 0x00, // Authority RRs: 0
			0x00, 0x00, // Additional RRs: 0
			// Name: CKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
			0x20, 0x43, 0x4B, 0x41, 0x41, 0x41, 0x41, 0x41,
			0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
			0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
			0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
			0x41, 0x00,
			0x00, 0x21, // Type: NBSTAT
			0x00, 0x01, // Class: IN
		}
	case 138: // NetBIOS Datagram Service
		return []byte{
			0x12, 0x34, // Transaction ID
			0x01, 0x10, // Flags: Response + Authoritative
			0x00, 0x01, // Questions: 1
			0x00, 0x01, // Answers: 1
			0x00, 0x00, // Authority RRs: 0
			0x00, 0x00, // Additional RRs: 0
			// Query Name
			0x20, 0x43, 0x4B, 0x41, 0x41, 0x41, 0x41, 0x41,
			0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
			0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
			0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
			0x41, 0x00,
			0x00, 0x21, // Type: NBSTAT
			0x00, 0x01, // Class: IN
		}
	case 1434: // SQL Server Resolution Protocol
		return []byte{0x02} // 最简单的探测包
	case 3306: // MySQL (UDP模式)
		return []byte{
			0x45, 0x00, 0x00, 0x40, // 基础MySQL握手探测
			0x00, 0x01, 0x00, 0x00,
			0x40, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		}
	case 5432: // PostgreSQL
		return []byte{
			0x00, 0x00, 0x00, 0x08, // Length: 8
			0x00, 0x03, 0x00, 0x00, // Cancel request
		}
	case 1900: // SSDP (Simple Service Discovery Protocol)
		return []byte("M-SEARCH * HTTP/1.1\r\nHost: 239.255.255.250:1900\r\nMan: \"ssdp:discover\"\r\nMX: 3\r\nST: ssdp:all\r\n\r\n")
	case 5353: // mDNS (Multicast DNS)
		return []byte{
			0x00, 0x00, // Transaction ID
			0x00, 0x00, // Flags: Query
			0x00, 0x01, // Questions: 1
			0x00, 0x00, // Answers: 0
			0x00, 0x00, // Authority RRs: 0
			0x00, 0x00, // Additional RRs: 0
			// _services._dns-sd._udp.local
			0x09, '_', 's', 'e', 'r', 'v', 'i', 'c', 'e', 's',
			0x07, '_', 'd', 'n', 's', '-', 's', 'd',
			0x04, '_', 'u', 'd', 'p',
			0x05, 'l', 'o', 'c', 'a', 'l', 0x00,
			0x00, 0x0C, // Type: PTR
			0x00, 0x01, // Class: IN
		}
	case 27015: // Steam
		return []byte{
			0xFF, 0xFF, 0xFF, 0xFF, // -1
			0x54,                                                                                                                   // 'T'
			0x53, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x45, 0x6E, 0x67, 0x69, 0x6E, 0x65, 0x20, 0x51, 0x75, 0x65, 0x72, 0x79, 0x00, // "Source Engine Query"
		}
	case 19132: // Minecraft
		return []byte{
			0x01,                                           // Packet ID: Unconnected Ping
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Timestamp
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Magic
		}
	default:
		// 对于未知端口，发送多种通用探测数据
		if port < 1024 {
			// 系统服务端口，发送空包
			return []byte{}
		} else if port < 10000 {
			// 常见应用端口，发送HTTP-like探测
			return []byte("GET / HTTP/1.0\r\n\r\n")
		} else {
			// 高端口号，发送二进制探测
			return []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05}
		}
	}
}
